#!/usr/bin/env python3
"""
Convert DTS (Device Tree Source) into a C array.
"""
import os
import sys
import argparse
from string import Template
from functools import reduce

import fdt


OUTPUT_TEMPLATE = Template("""
/* Device hints internal representation.
 *
 * WARNING: This file is autogenerated and should NOT be modified directly.
 * Please refer to `${input}` file in case you would like to change
 * any of the values.
 */
#include <stdint.h>

/* TODO: Move structures to device.h ? */

/* memory or io-port address range */
typedef struct dh_range {
    uintptr_t start, end;
} dh_range_t;

typedef struct {
    const char *path;
    dh_range_t **iomem;
    dh_range_t **ioport;
    uint32_t irq;
} devhint_t;

devhint_t ${platform}_hints[] = {
${hints}
};
""")


def generate_fdt(filename):
    with open(filename, 'r') as f:
        data = f.read()
        dtb = fdt.parse_dts(data)
    return dtb


def make_pairs(lst):
    return [(lst[i], lst[i + 1]) for i in range(0, len(lst), 2)]


def generate_hints(device, path):
    for prop in device.props:
        yield ('.path', path)

        if prop.name == 'iomem':
            yield ('.iomem', make_pairs(prop.data))

        elif prop.name == 'ioport':
            yield ('.ioport', make_pairs(prop.data))

        elif prop.name == 'interrupts':
            assert len(prop.data) == 1, "Only one irq per device supported!"
            yield ('.irq', prop.data[0])

        else:
            raise ValueError("The following device hint resource is "
                             "not supported: {}".format(prop.name))


def flatten_fdt(root, path):
    child_hints = [flatten_fdt(node, "{}/{}".format(path, node.name))
                   for node in root.nodes]

    hints = reduce(lambda a, b: {**a, **b}, child_hints, {})
    current_device_hints = dict(generate_hints(root, path))
    if current_device_hints:
        hints[path] = current_device_hints
    return hints


def to_c_value(val):
    if isinstance(val, str):
        return '"{}"'.format(val)
    if isinstance(val, int):
        return hex(val)
    if isinstance(val, list):
        ranges = ['&(dh_range_t){.start = 0x%x, .end = 0x%x}' % (start, end)
                  for start, end in val]
        ranges.append('(dh_range_t *)0')
        return '(dh_range_t *[]){' + ', '.join(ranges) + '}'
    raise ValueError(repr(val))


def hint_as_c_entry(hint):
    fields_as_strs = [
        "\t{} = {}".format(resource, to_c_value(value))
        for resource, value in hint.items()]
    return '{' + ',\n'.join(fields_as_strs) + '}\n,\n'


def device_hints_as_c_array(hints):
    return ''.join(map(hint_as_c_entry, hints.values()))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
            description='Converting DTS (Device Tree Source) into a C array.')
    parser.add_argument('input', metavar='DTS', type=str,
                        help='Device Tree Source file')
    parser.add_argument('output', metavar='SRC', type=str,
                        help='C array of devhint_t structures')
    args = parser.parse_args()

    fdt = generate_fdt(args.input)
    flat_hints = flatten_fdt(fdt.root_node, '/rootdev')
    hints_as_c_array = device_hints_as_c_array(flat_hints)
    with open(args.output, 'w') as f:
        f.write(OUTPUT_TEMPLATE.substitute(
            input=args.input,
            platform=os.path.splitext(args.input)[0],
            hints=hints_as_c_array))
