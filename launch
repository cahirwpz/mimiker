#!/usr/bin/python3

import argparse
import shutil
import os
import os.path
import signal
from launcher import *
        
if __name__ == '__main__':
    # Check if a cross-compiler is present
    common.find_toolchain()

    # Probe which tools are available.
    simulators, sim_default = common.find_available(SIMULATORS)
    outputs, out_default = common.find_available(OUTPUTS)
    debuggers, dbg_default = common.find_available(DEBUGGERS)

    if len(simulators) < 1:
        raise SystemExit('No simulators found!')

    parser = argparse.ArgumentParser(
        description='Launch kernel in Malta board simulator.')
    parser.add_argument('-k', '--kernel', metavar='KERNEL', type=str,
                        help='Kernel image file in ELF format.', default='mimiker.elf')
    parser.add_argument('args', metavar='ARGS',
                        type=str, nargs='*', help='Kernel arguments.')
    parser.add_argument('-D', '--debugger', metavar='DEBUGGER', type=str, choices=debuggers.keys(), default=dbg_default, help=(
        'Selet the debugger to attach. ' + 'Available options: %s. Default: %s.' % (', '.join(sorted(debuggers)), dbg_default)))
    parser.add_argument(
        '-S', '--simulator', metavar='SIMULATOR', type=str, choices=simulators.keys(), default=sim_default,
                        help=('Simulator to use. ' + 'Available options: %s. Default: %s.' % (', '.join(sorted(simulators)), sim_default)))
    parser.add_argument('-O', '--output', metavar='OUTPUT', type=str, choices=outputs, default=out_default, help=(
        'Where to direct UART output and kernel messages. ' + 'Available options: %s. Default: %s.' % (', '.join(sorted(outputs)), out_default)))

    parser.add_argument(
        '-t', action='store_true', help='Shorthand for --output stdio')
    parser.add_argument(
        '-s', action='store_true', help='Shorthand for --output server')
    parser.add_argument(
        '-d', action='store_true', help='Shorthand for --debugger cgdb.')

    args = parser.parse_args()

    # Check if the kernel file is available
    if not os.path.isfile(args.kernel):
        raise SystemExit('%s: file does not exist!' % args.kernel)

    # Support convenient -s and -t options
    if args.t and args.s:
        raise SystemExit('Options -s and -t are exclusive')
    elif args.t:
        args.output = 'stdio'
    elif args.s:
        args.output = 'server'

    # Support -d option
    if args.d:
        args.debugger = 'cgdb'

    debug = args.debugger != 'none'

    if debug and args.output == 'stdio':
        raise SystemExit(
            'ERROR: Unable to start both debugger and simulator in stdio output mode.')

    sim = simulators[args.simulator]
    out = outputs[args.output]
    dbg = debuggers[args.debugger]

    sim.configure(args.kernel, ' '.join(args.args), debug, UART_PORT)
    out.configure(args.kernel, ' '.join(args.args), debug, UART_PORT)
    dbg.configure(args.kernel, ' '.join(args.args), debug, UART_PORT)

    # When the debugger exits, we'll regain the terminal foreground. This
    # generates SIGTTOU which normally kills the process, so we need to ignore
    # this signal.
    signal.signal(signal.SIGTTOU, signal.SIG_IGN)
    
    sim.start()
    out.start()
    dbg.start()

    # Wait until any of these program terminates. This way the user may end
    # their session by either closing the simulator, the debugger, or even the
    # xterm window.
    try:
        common.wait_any([out, sim, dbg])
    except KeyboardInterrupt:
        pass

    # Stop the programs in reverse order, less chance they'll be confused
    dbg.stop()
    out.stop()
    sim.stop()
