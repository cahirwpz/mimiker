#!/usr/bin/env python3

import argparse
import os
import os.path
import string
import shutil
import signal
import subprocess
import itertools
from libtmux import Server, Session


TMUX_CONF = './.tmux.conf'
TARGET = 'mipsel'
UART_PORT_BASE = 8000
GDB_PORT_BASE = 9100


class Launchable():
    def __init__(self, name, cmd):
        self.name = name
        self.cmd = cmd
        self.window = None
        self.options = []

    def configure(self, *args, **kwargs):
        raise NotImplementedError

    def start(self, session):
        cmd = ' '.join([self.cmd] + self.options)
        self.window = session.new_window(
            attach=False, window_name=self.name, window_shell=cmd)

    def run(self):
        self.process = subprocess.Popen([self.cmd] + self.options,
                                        start_new_session=False)

    # Returns true iff the process terminated
    def wait(self, timeout=None):
        if self.process is None:
            return False
        # Throws exception on timeout
        self.process.wait(timeout)
        self.process = None
        return True

    def stop(self):
        if self.process is None:
            return
        try:
            # Give it a chance to exit gracefuly.
            self.process.send_signal(signal.SIGTERM)
            try:
                self.process.wait(0.2)
            except subprocess.TimeoutExpired:
                self.process.send_signal(signal.SIGKILL)
        except ProcessLookupError:
            # Process already quit.
            pass
        self.process = None

    def interrupt(self):
        if self.process is not None:
            self.process.send_signal(signal.SIGINT)


def wait_any(launchables):
    for l in itertools.cycle(launchables):
        try:
            if l.wait(0.2):
                break
        except subprocess.TimeoutExpired:
            continue


class QEMU(Launchable):
    def __init__(self):
        super().__init__('qemu', shutil.which('qemu-mimiker-' + TARGET))

    def configure(self, debug=False, graphics=False, kernel='', args='',
                  gdb_port='', uart0_port='', uart1_port='', uart2_port=''):
        self.options = [
            '-nodefaults',
            '-device', 'VGA',
            '-machine', 'malta',
            '-cpu', '24Kf',
            '-icount', 'shift=3,sleep=on',
            '-kernel', kernel,
            '-append', ' '.join(args),
            '-gdb', 'tcp:127.0.0.1:{},server,wait'.format(gdb_port),
            '-serial', 'none',
            '-serial', 'tcp:127.0.0.1:{},server,wait'.format(uart0_port),
            '-serial', 'tcp:127.0.0.1:{},server,wait'.format(uart1_port),
            '-serial', 'tcp:127.0.0.1:{},server,wait'.format(uart2_port)]

        if debug:
            self.options += ['-S']
        if not graphics:
            self.options += ['-display', 'none']


class GDB(Launchable):
    COMMAND = TARGET + '-mimiker-elf-gdb'

    def __init__(self, name=None, cmd=None):
        super().__init__(name or 'gdb', cmd or GDB.COMMAND)
        # gdbtui & cgdb output is garbled if there no delay
        self.cmd = 'sleep 0.25 && ' + self.cmd

    def configure(self, kernel='', gdb_port=''):
        if self.name == 'gdb':
            self.options += ['-ex="set prompt \033[35;1m(gdb) \033[0m"']
        self.options += [
            '-iex="set auto-load safe-path {}/"'.format(os.getcwd()),
            '-ex="set tcp connect-timeout 30"',
            '-ex="target remote localhost:{}"'.format(gdb_port),
            '-ex="continue"',
            '--silent',
            kernel]


class GDBTUI(GDB):
    def __init__(self):
        super().__init__('gdbtui')
        self.options = ['-tui']


class CGDB(GDB):
    def __init__(self):
        super().__init__('cgdb', 'cgdb')
        self.options = ['-d', GDB.COMMAND]


class SOCAT(Launchable):
    def __init__(self, name):
        super().__init__(name, 'socat')

    def configure(self, uart_port=''):
        # The simulator will only open the server after some time has
        # passed. OVPsim needs as much as 1 second. To minimize the delay, keep
        # reconnecting until success.
        self.options = [
            'STDIO', 'tcp:localhost:{},retry,forever'.format(uart_port)]


if __name__ == '__main__':
    debuggers = {'gdb': GDB, 'gdbtui': GDBTUI, 'cgdb': CGDB}

    parser = argparse.ArgumentParser(
        description='Launch kernel in Malta board simulator.')
    parser.add_argument('-k', '--kernel', metavar='KERNEL', type=str,
                        default='mimiker.elf',
                        help='Kernel image file in ELF format.')
    parser.add_argument('args', metavar='ARGS', type=str, nargs='*',
                        help='Kernel arguments.')
    parser.add_argument('-D', '--debugger', metavar='DEBUGGER', type=str,
                        choices=debuggers.keys(), default='gdb',
                        help=('Run debugging sesion with selected debugger. '
                              'Available options: %s. Default: %s.' %
                              (', '.join(sorted(debuggers.keys())), 'gdb')))
    parser.add_argument('-d', '--debug', action='store_true',
                        help='Start debugging session with selected debugger.')
    parser.add_argument('-t', '--test-run', action='store_true',
                        help='Test-run mode: simulator output goes to stdout.')
    parser.add_argument('-g', '--graphics', action='store_true',
                        help='Enable VGA output.')
    args = parser.parse_args()

    # Check if the kernel file is available
    if not os.path.isfile(args.kernel):
        raise SystemExit('%s: file does not exist!' % args.kernel)

    uart_port = UART_PORT_BASE + os.getuid()
    gdb_port = GDB_PORT_BASE + os.getuid()

    sim = QEMU()
    sim.configure(args.debug, args.graphics, args.kernel, args.args, gdb_port,
                  uart_port, uart_port + 1, uart_port + 2)

    uart0 = SOCAT('/dev/tty1')
    uart0.configure(uart_port=uart_port + 0)

    uart1 = SOCAT('/dev/tty2')
    uart1.configure(uart_port=uart_port + 1)

    uart2 = SOCAT('/dev/cons')
    uart2.configure(uart_port=uart_port + 2)

    if args.debug:
        dbg = debuggers[args.debugger]()
        dbg.configure(kernel=args.kernel, gdb_port=gdb_port)

    if args.test_run:
        sim.run()
        uart0.run()
        uart1.run()
        uart2.run()

        print('Waiting...')
        try:
            wait_any([sim, uart0, uart1, uart2])
        except KeyboardInterrupt:
            pass

        uart2.stop()
        sim.stop()

        raise SystemExit

    subprocess.run(['tmux', '-f', TMUX_CONF, 'start-server'])

    server = Server(config_file=TMUX_CONF)

    if server.has_session('mimiker'):
        server.kill_session('mimiker')

    session = server.new_session(session_name='mimiker', attach=False,
                                 window_name=':0', window_command='sleep 1000')

    try:
        sim.start(session)
        uart0.start(session)
        uart1.start(session)
        uart2.start(session)
        if args.debug:
            dbg.start(session)

        session.kill_window(':0')
        session.select_window(args.debugger if args.debug else '/dev/cons')
        session.attach_session()
        session.kill_session()
    except Exception as ex:
        session.kill_session()
        raise ex
